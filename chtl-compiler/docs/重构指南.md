# CHTL 编译器重构指南

## 概述

虽然当前代码库存在一些问题，但基础架构完善，重构工作量并不大。本指南将帮助您系统地改进代码质量，实现一个可工作的 CHTL 编译器。

## 1. 架构评估

### 优点
- ✅ 模块化设计清晰（Scanner、Parser、Generator、Dispatcher）
- ✅ CHTL 和 CHTL JS 完全独立
- ✅ AST 节点体系完整
- ✅ 扩展机制（CMOD/CJMOD）设计合理

### 需要改进的地方
- ❌ 部分概念过度抽象（如 VAR_CALL）
- ❌ Parser 和 Generator 实现不完整
- ❌ 状态机利用不充分
- ❌ 缺少测试用例

## 2. 重构优先级

### 第一阶段：让它工作（1-2周）

#### 2.1 简化 AST 节点
```cpp
// 删除不必要的节点类型
// BAD: 过度细分
class VarCallNode;      // 删除
class VarAccessNode;    // 删除

// GOOD: 使用状态机判断上下文
class IdentifierNode {  // 保留，通过上下文判断用途
    bool IsDeclaration() const { return m_Context == Context::Declaration; }
    bool IsReference() const { return m_Context == Context::Expression; }
};
```

#### 2.2 实现核心 Parser
```cpp
class CHTLParser {
    // 专注于核心语法
    std::shared_ptr<DocumentNode> Parse(const std::vector<Token>& tokens) {
        m_Current = 0;
        m_Tokens = tokens;
        
        auto doc = std::make_shared<DocumentNode>();
        while (!IsAtEnd()) {
            doc->AddChild(ParseTopLevel());
        }
        return doc;
    }
    
private:
    // 实现基本解析方法
    std::shared_ptr<ASTNode> ParseElement();     // div { ... }
    std::shared_ptr<ASTNode> ParseText();        // text { ... }
    std::shared_ptr<ASTNode> ParseStyle();       // style { ... }
    std::shared_ptr<ASTNode> ParseAttribute();   // class: "test";
};
```

#### 2.3 实现基础 Generator
```cpp
class CHTLGenerator {
    // 生成 HTML
    std::string Generate(DocumentNode* doc) {
        m_Output.clear();
        doc->Accept(this);
        return m_Output.str();
    }
    
    // 实现访问者方法
    void VisitElement(ElementNode* node) {
        m_Output << "<" << node->GetTagName();
        // 处理属性
        for (auto& attr : node->GetAttributes()) {
            m_Output << " " << attr->GetName() << "=\"" << attr->GetValue() << "\"";
        }
        m_Output << ">";
        // 处理子节点
        for (auto& child : node->GetChildren()) {
            child->Accept(this);
        }
        m_Output << "</" << node->GetTagName() << ">";
    }
};
```

### 第二阶段：让它正确（2-3周）

#### 2.4 完善状态机使用
```cpp
class CHTLStateContextHelper {
    // 自动管理状态转换
    CHTLStateContextHelper(CHTLStateMachine* sm, State newState) 
        : m_StateMachine(sm), m_OldState(sm->GetCurrentState()) {
        m_StateMachine->TransitionTo(newState);
    }
    
    ~CHTLStateContextHelper() {
        m_StateMachine->TransitionTo(m_OldState);
    }
};

// 使用示例
void ParseStyleBlock() {
    CHTLStateContextHelper helper(&m_StateMachine, State::InStyle);
    // 在样式上下文中解析
}
```

#### 2.5 添加错误处理
```cpp
class CompileError {
    std::string m_Message;
    size_t m_Line;
    size_t m_Column;
    std::string m_Filename;
    
    std::string Format() const {
        return fmt::format("{}:{}:{}: error: {}", 
            m_Filename, m_Line, m_Column, m_Message);
    }
};
```

#### 2.6 实现测试框架
```cpp
TEST(CHTLParser, BasicElement) {
    std::string input = "div { text { Hello } }";
    auto result = CompileCHTL(input);
    EXPECT_EQ(result, "<div>Hello</div>");
}

TEST(CHTLParser, Attributes) {
    std::string input = "div { class: \"test\"; id: \"main\"; }";
    auto result = CompileCHTL(input);
    EXPECT_EQ(result, "<div class=\"test\" id=\"main\"></div>");
}
```

### 第三阶段：让它优雅（1个月）

#### 2.7 性能优化
- 使用字符串流而非字符串拼接
- 实现 Token 缓存
- 优化 AST 遍历

#### 2.8 高级特性
- 完整的模板系统
- Import/Namespace 支持
- CMOD/CJMOD 集成
- 约束系统

## 3. 具体重构步骤

### Step 1: 清理和简化（1天）
```bash
# 1. 删除过度抽象的节点
rm include/chtl/ast/*CallNode.h
rm include/chtl/ast/*AccessNode.h

# 2. 合并相似功能
# 将 StringLiteralNode、UnquotedLiteralNode 统一为 LiteralNode

# 3. 修复编译错误
```

### Step 2: 实现最小可行版本（3-5天）
```cpp
// main_simple.cpp
int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: chtl <input.chtl>\n";
        return 1;
    }
    
    // 读取输入
    std::string input = ReadFile(argv[1]);
    
    // 简单编译
    SimpleCHTLCompiler compiler;
    std::string html = compiler.Compile(input);
    
    // 输出结果
    std::cout << html;
    return 0;
}
```

### Step 3: 逐步完善（持续）
1. 添加更多语法支持
2. 改进错误消息
3. 优化性能
4. 添加 IDE 支持

## 4. 关键原则

### 4.1 YAGNI (You Aren't Gonna Need It)
- 不要预先设计未使用的功能
- 先实现基础功能，再考虑扩展

### 4.2 测试驱动
- 每个功能都要有对应的测试
- 测试用例就是最好的文档

### 4.3 渐进式改进
- 不要试图一次解决所有问题
- 保持代码始终可编译、可运行

## 5. 工具和资源

### 开发工具
- **编译器**: g++ 或 clang++ (C++17)
- **构建系统**: CMake
- **测试框架**: Google Test
- **格式化**: clang-format
- **静态分析**: clang-tidy

### 参考资源
- [Writing An Interpreter In Go](https://interpreterbook.com/)
- [Crafting Interpreters](https://craftinginterpreters.com/)
- ANTLR4 文档（用于 CSS/JS 解析）

## 6. 时间估算

| 阶段 | 任务 | 预计时间 |
|-----|------|---------|
| 清理 | 删除冗余代码，修复编译错误 | 1-2天 |
| MVP | 实现基础 CHTL→HTML 转换 | 3-5天 |
| 测试 | 添加单元测试和集成测试 | 2-3天 |
| 优化 | 性能优化和代码重构 | 1周 |
| 高级 | 模板、Import、CMOD 等 | 2-3周 |
| 总计 | 可工作的完整版本 | 1-1.5个月 |

## 7. 快速开始

```bash
# 1. 克隆仓库
git clone https://github.com/Yhlight/sagnjajnesbh.git
cd sagnjajnesbh

# 2. 创建简化分支
git checkout -b simplified-version

# 3. 清理代码
# 删除过度设计的部分

# 4. 实现核心功能
# 专注于基本的 CHTL→HTML 转换

# 5. 测试
mkdir build && cd build
cmake ..
make
./chtl ../examples/simple.chtl
```

## 总结

重构的关键是：
1. **先让它工作**，再让它优雅
2. **删除过度设计**，保持简单
3. **测试驱动开发**，确保正确性
4. **渐进式改进**，不断迭代

记住：一个能工作的简单版本，胜过一个不能工作的完美架构。