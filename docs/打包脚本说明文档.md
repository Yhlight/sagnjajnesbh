# CHTL打包脚本说明文档

## 📋 概述

CHTL项目的打包脚本系统专门用于将CHTL模块打包成标准的分发格式。该系统支持CMOD（CHTL组件模块）和CJMOD（CHTL JS扩展模块）两种模块类型，严格按照CHTL语法文档的模块规范进行打包和验证。

## 📦 模块打包概念

### 模块类型

**CMOD模块（CHTL Module）：**
- 纯CHTL语法编写的组件模块
- 包含样式、元素、模板和配置
- 文件格式：`.cmod`（实际为ZIP格式）
- 示例：珂朵莉模块、由比滨结衣模块

**CJMOD模块（CHTL JS Module）：**
- C++编写的CHTL JS扩展模块
- 提供原生性能的功能扩展
- 文件格式：`.cjmod`（实际为ZIP格式）
- 示例：printMylove、iNeverAway

**混合模块：**
- 同时包含CMOD和CJMOD的复合模块
- 目录结构：`ModuleName/CMOD/` 和 `ModuleName/CJMOD/`
- 分别打包成独立的.cmod和.cjmod文件
- 示例：珂朵莉模块（混合架构）

### 模块结构规范

根据CHTL语法文档，标准模块结构如下：

**CMOD模块结构：**
```
ComponentName/
├── src/
│   ├── ComponentName.chtl    # 主源文件 ✓ 必需
│   └── Additional.chtl        # 其他源文件 ○ 可选
└── info/
    └── ComponentName.chtl     # 模块信息文件 ✓ 必需
```

**CJMOD模块结构：**
```
ExtensionName/
├── src/
│   ├── ExtensionName.cpp      # C++源文件 ✓ 建议
│   ├── ExtensionName.h        # C++头文件 ✓ 建议
│   └── *.cpp, *.h             # 其他源文件 ○ 可选
└── info/
    └── ExtensionName.chtl     # 模块信息文件 ✓ 必需
```

## 🔧 CMOD打包脚本详解

### 脚本文件

**位置：**
- Windows: `scripts/windows/package_cmod.bat`
- Linux: `scripts/linux/package_cmod.sh`
- macOS: `scripts/macos/package_cmod.sh`

### 使用方法

**基础语法：**
```bash
# Windows
scripts\windows\package_cmod.bat <模块路径>

# Linux/macOS
scripts/linux/package_cmod.sh <模块路径>
```

**实际示例：**
```bash
# 打包珂朵莉核心模块
scripts/windows/package_cmod.bat Chtholly\CMOD\Core

# 打包由比滨结衣音乐播放器
scripts/linux/package_cmod.sh Yuigahama/CMOD/MusicPlayer

# 打包手风琴组件
scripts/macos/package_cmod.sh Chtholly/CMOD/Accordion
```

### 脚本执行流程

**第一步：路径验证**
```bash
# 检查输入参数
if [ $# -eq 0 ]; then
    echo "错误：未提供模块路径"
    exit 1
fi

# 验证模块目录存在
if [ ! -d "${SOURCE_DIR}/${MODULE_PATH}" ]; then
    echo "错误：模块路径不存在 ${MODULE_PATH}"
    exit 1
fi
```

**第二步：模块名称提取**
```bash
# 从路径中提取模块名称
MODULE_NAME="$(basename "${MODULE_PATH}")"
echo "正在打包CMOD模块: ${MODULE_NAME}"
```

**第三步：临时目录创建**
```bash
# 创建临时打包目录
TEMP_DIR="/tmp/chtl_cmod_package_$$"
mkdir -p "${TEMP_DIR}/${MODULE_NAME}"
```

**第四步：文件结构复制**
```bash
# 复制src目录
cp -r "${SOURCE_DIR}/${MODULE_PATH}/src" "${TEMP_DIR}/${MODULE_NAME}/"

# 复制info目录
cp -r "${SOURCE_DIR}/${MODULE_PATH}/info" "${TEMP_DIR}/${MODULE_NAME}/"
```

**第五步：结构完整性验证**
```bash
# 检查主源文件
if [ ! -f "${TEMP_DIR}/${MODULE_NAME}/src/${MODULE_NAME}.chtl" ]; then
    echo "警告：主源文件 ${MODULE_NAME}.chtl 未在src目录中找到"
fi

# 检查信息文件
if [ ! -f "${TEMP_DIR}/${MODULE_NAME}/info/${MODULE_NAME}.chtl" ]; then
    echo "警告：信息文件 ${MODULE_NAME}.chtl 未在info目录中找到"
fi
```

**第六步：打包压缩**
```bash
# 创建.cmod包
PACKAGE_FILE="${DIST_DIR}/${MODULE_NAME}.cmod"
cd "${TEMP_DIR}"
zip -r "${PACKAGE_FILE}" "${MODULE_NAME}" > /dev/null
```

**第七步：清理工作**
```bash
# 删除临时目录
rm -rf "${TEMP_DIR}"

echo "CMOD打包完成: ${PACKAGE_FILE}"
```

### 信息文件格式

根据CHTL语法文档，信息文件应包含以下内容：

```chtl
[Info] {
    name = "ModuleName";
    version = "1.0.0";
    description = "模块描述";
    author = "作者名称";
    license = "MIT";
    dependencies = "RequiredModule";
    category = "ui-component";
    minCHTLVersion = "1.0.0";
    maxCHTLVersion = "2.0.0";
    keywords = "component,ui,library";
    features = "responsive,accessible,customizable";
}

[Export] {
    [Template] @Style ModuleStyle;
    [Template] @Element ModuleElement;
    [Template] @Var ModuleVariable;
    [Custom] @Style CustomStyle;
    [Custom] @Element CustomElement;
    [Origin] @Html HtmlBlock;
    [Origin] @Style StyleBlock;
    [Origin] @JavaScript ScriptBlock;
    [Configuration] @Config ModuleConfig;
}
```

## ⚡ CJMOD打包脚本详解

### 脚本文件

**位置：**
- Windows: `scripts/windows/package_cjmod.bat`
- Linux: `scripts/linux/package_cjmod.sh`
- macOS: `scripts/macos/package_cjmod.sh`

### 使用方法

**基础语法：**
```bash
# Windows
scripts\windows\package_cjmod.bat <模块路径>

# Linux/macOS
scripts/linux/package_cjmod.sh <模块路径>
```

**实际示例：**
```bash
# 打包printMylove扩展
scripts/windows/package_cjmod.bat Chtholly\CJMOD\printMylove

# 打包iNeverAway扩展
scripts/linux/package_cjmod.sh Chtholly/CJMOD/iNeverAway
```

### 脚本执行流程

**第一步：路径和参数验证**
```bash
# 与CMOD脚本相同的验证流程
if [ $# -eq 0 ]; then
    echo "用法: $0 <模块路径>"
    echo "示例: $0 Chtholly/CJMOD/printMylove"
    exit 1
fi
```

**第二步：C++文件验证**
```bash
# 检查C++源文件存在性
CPP_FOUND=0
if [ -n "$(find "${TEMP_DIR}/${MODULE_NAME}/src" -name "*.cpp" -o -name "*.h" 2>/dev/null)" ]; then
    CPP_FOUND=1
fi

if [ $CPP_FOUND -eq 0 ]; then
    echo "警告：src目录中未找到C++源文件（.cpp/.h）"
fi
```

**第三步：其他流程**
- 与CMOD脚本的其他步骤基本相同
- 最终生成`.cjmod`格式的包文件

### CJMOD信息文件

CJMOD的信息文件格式与CMOD类似，但需要包含C++相关信息：

```chtl
[Info] {
    name = "ExtensionName";
    version = "1.0.0";
    description = "C++扩展模块描述";
    author = "作者名称";
    license = "MIT";
    category = "native-extension";
    
    // C++特定信息
    cppStandard = "17";
    compilerRequirements = "GCC 9+, Clang 10+, MSVC 2019+";
    dependencies = "CHTL Core";
    
    // 平台兼容性
    platforms = "Windows,Linux,macOS";
    architecture = "x64,ARM64";
}

[Export] {
    // CJMOD导出的函数和类
    [Function] printMylove;
    [Function] iNeverAway;
    [Class] CHTLJSExtension;
}
```

## 🎯 统一打包脚本

### 智能模块识别

统一打包脚本能够自动识别模块类型：

**路径模式识别：**
```bash
# 检查路径中的关键字
if echo "${MODULE_PATH}" | grep -i "CMOD" > /dev/null; then
    MODULE_TYPE="CMOD"
elif echo "${MODULE_PATH}" | grep -i "CJMOD" > /dev/null; then
    MODULE_TYPE="CJMOD"
fi
```

**内容自动检测：**
```bash
# 如果路径模式不明确，检查文件内容
if [ -z "${MODULE_TYPE}" ]; then
    if find "${SOURCE_DIR}/${MODULE_PATH}/src" -name "*.cpp" -o -name "*.h" 2>/dev/null | grep -q .; then
        MODULE_TYPE="CJMOD"
    else
        MODULE_TYPE="CMOD"
    fi
fi
```

**调用相应脚本：**
```bash
case "${MODULE_TYPE}" in
    "CMOD")
        echo "调用CMOD打包脚本..."
        "${SCRIPT_DIR}/package_cmod.sh" "${MODULE_PATH}"
        ;;
    "CJMOD")
        echo "调用CJMOD打包脚本..."
        "${SCRIPT_DIR}/package_cjmod.sh" "${MODULE_PATH}"
        ;;
    *)
        echo "错误：无法识别模块类型"
        exit 1
        ;;
esac
```

## 📁 模块搜索路径规范

根据CHTL语法文档和最新的模块搜索路径修正，打包脚本支持以下模块结构：

### 无序结构

模块文件直接放置在module文件夹根目录：

```
module/
├── Component1.cmod
├── Component2.chtl
├── Extension1.cjmod
├── Extension2.cpp
└── Extension2.h
```

### 有序结构

按模块类型分类的目录结构：

```
module/
├── CMOD/           # 或 Cmod/ 或 cmod/
│   ├── Component1.cmod
│   └── Component2.chtl
├── CJMOD/          # 或 CJmod/ 或 cjmod/
│   ├── Extension1.cjmod
│   └── Extension2.cpp
└── chtl/           # CHTL源文件
    └── Template.chtl
```

### 混合结构支持

**标准混合模块：**
```
Chtholly/
├── CMOD/
│   ├── Core/
│   ├── Accordion/
│   └── ProgressBar/
└── CJMOD/
    ├── printMylove/
    └── iNeverAway/
```

**扁平混合模块：**
```
ModuleName/
├── ComponentA.cmod
├── ComponentB.chtl
├── ExtensionA.cjmod
└── ExtensionB.cpp
```

## 🔍 打包验证和质量控制

### 文件完整性检查

**CMOD模块验证：**
```bash
# 必需文件检查
check_cmod_structure() {
    local module_dir="$1"
    local module_name="$2"
    
    # 检查src目录
    if [ ! -d "${module_dir}/src" ]; then
        echo "错误：缺少src目录"
        return 1
    fi
    
    # 检查info目录
    if [ ! -d "${module_dir}/info" ]; then
        echo "错误：缺少info目录"
        return 1
    fi
    
    # 检查主源文件
    if [ ! -f "${module_dir}/src/${module_name}.chtl" ]; then
        echo "警告：建议包含主源文件 ${module_name}.chtl"
    fi
    
    # 检查信息文件
    if [ ! -f "${module_dir}/info/${module_name}.chtl" ]; then
        echo "错误：缺少信息文件 ${module_name}.chtl"
        return 1
    fi
    
    return 0
}
```

**CJMOD模块验证：**
```bash
# C++文件检查
check_cjmod_structure() {
    local module_dir="$1"
    local module_name="$2"
    
    # 基础结构检查（与CMOD相同）
    check_cmod_structure "$module_dir" "$module_name"
    local base_result=$?
    
    # C++文件检查
    local cpp_files=$(find "${module_dir}/src" -name "*.cpp" -o -name "*.h" 2>/dev/null | wc -l)
    if [ "$cpp_files" -eq 0 ]; then
        echo "警告：未找到C++源文件，确认这是CJMOD模块吗？"
    fi
    
    return $base_result
}
```

### 语法文档合规性验证

**信息文件解析：**
```bash
# 验证信息文件格式
validate_info_file() {
    local info_file="$1"
    
    # 检查[Info]块存在
    if ! grep -q "^\[Info\]" "$info_file"; then
        echo "错误：信息文件缺少[Info]块"
        return 1
    fi
    
    # 检查必需字段
    local required_fields=("name" "version" "description")
    for field in "${required_fields[@]}"; do
        if ! grep -q "^[[:space:]]*${field}[[:space:]]*=" "$info_file"; then
            echo "警告：建议包含${field}字段"
        fi
    done
    
    # 检查[Export]块（可选但推荐）
    if grep -q "^\[Export\]" "$info_file"; then
        echo "信息：包含Export块，用于性能优化和访问控制"
    fi
    
    return 0
}
```

### 包完整性验证

**生成的包文件验证：**
```bash
# 验证生成的包文件
verify_package() {
    local package_file="$1"
    local module_name="$2"
    
    # 检查文件存在
    if [ ! -f "$package_file" ]; then
        echo "错误：包文件生成失败"
        return 1
    fi
    
    # 检查文件大小
    local file_size=$(stat -f%z "$package_file" 2>/dev/null || stat -c%s "$package_file" 2>/dev/null)
    if [ "$file_size" -lt 1024 ]; then
        echo "警告：包文件过小，可能存在问题"
    fi
    
    # 检查ZIP完整性
    if command -v unzip >/dev/null 2>&1; then
        if unzip -t "$package_file" >/dev/null 2>&1; then
            echo "包文件完整性验证通过"
        else
            echo "错误：包文件损坏"
            return 1
        fi
    fi
    
    return 0
}
```

## 📊 打包性能和优化

### 压缩选项优化

**压缩级别配置：**
```bash
# 根据模块大小选择压缩级别
optimize_compression() {
    local source_dir="$1"
    local total_size=$(du -s "$source_dir" | cut -f1)
    
    if [ "$total_size" -lt 1024 ]; then
        # 小模块：快速压缩
        COMPRESSION_LEVEL="-1"
    elif [ "$total_size" -lt 10240 ]; then
        # 中等模块：平衡压缩
        COMPRESSION_LEVEL="-6"
    else
        # 大模块：最优压缩
        COMPRESSION_LEVEL="-9"
    fi
    
    zip $COMPRESSION_LEVEL -r "$package_file" "$module_name"
}
```

### 并行打包

**批量打包优化：**
```bash
# 并行打包多个模块
batch_package() {
    local modules=("$@")
    local max_jobs=4
    local job_count=0
    
    for module in "${modules[@]}"; do
        if [ $job_count -ge $max_jobs ]; then
            wait  # 等待一些任务完成
            job_count=0
        fi
        
        echo "开始打包: $module"
        package_module "$module" &
        ((job_count++))
    done
    
    wait  # 等待所有任务完成
}
```

### 缓存机制

**增量打包：**
```bash
# 检查模块是否需要重新打包
needs_repackaging() {
    local module_path="$1"
    local package_file="$2"
    
    # 如果包不存在，需要打包
    if [ ! -f "$package_file" ]; then
        return 0
    fi
    
    # 检查源文件是否比包更新
    if [ "$module_path" -nt "$package_file" ]; then
        return 0
    fi
    
    # 不需要重新打包
    return 1
}
```

## 🛠️ 高级打包功能

### 依赖关系处理

**模块依赖检查：**
```bash
# 解析模块依赖
parse_dependencies() {
    local info_file="$1"
    
    # 提取dependencies字段
    local deps=$(grep "dependencies[[:space:]]*=" "$info_file" | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/')
    
    if [ -n "$deps" ]; then
        echo "模块依赖: $deps"
        # TODO: 验证依赖模块是否存在
    fi
}
```

### 版本兼容性检查

**CHTL版本验证：**
```bash
# 检查CHTL版本兼容性
check_version_compatibility() {
    local info_file="$1"
    
    local min_version=$(grep "minCHTLVersion" "$info_file" | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/')
    local max_version=$(grep "maxCHTLVersion" "$info_file" | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/')
    
    if [ -n "$min_version" ]; then
        echo "最低CHTL版本要求: $min_version"
    fi
    
    if [ -n "$max_version" ]; then
        echo "最高CHTL版本支持: $max_version"
    fi
}
```

### 数字签名支持

**包签名验证：**
```bash
# 为包添加数字签名（可选功能）
sign_package() {
    local package_file="$1"
    local private_key="$2"
    
    if [ -f "$private_key" ] && command -v openssl >/dev/null 2>&1; then
        echo "为包添加数字签名..."
        openssl dgst -sha256 -sign "$private_key" -out "${package_file}.sig" "$package_file"
        echo "签名文件: ${package_file}.sig"
    fi
}
```

## 🔧 故障排除

### 常见打包问题

**问题1：模块路径错误**
```
错误：Module path not found: Chtholly\CMOD\Core
解决：
1. 检查路径分隔符（Windows用\，Linux/macOS用/）
2. 确认模块目录确实存在
3. 检查路径拼写是否正确
```

**问题2：文件权限问题**
```
错误：Permission denied when creating package
解决：
1. chmod +x scripts/linux/*.sh
2. 确保对dist目录有写权限
3. 检查临时目录权限
```

**问题3：ZIP命令缺失**
```
错误：zip: command not found
解决：
1. Linux: sudo apt install zip
2. macOS: brew install zip
3. Windows: 脚本使用PowerShell压缩
```

**问题4：包文件损坏**
```
错误：Package file is corrupted
解决：
1. 检查磁盘空间是否充足
2. 验证源文件完整性
3. 重新运行打包脚本
```

**问题5：模块结构不符合规范**
```
警告：Main source file not found
解决：
1. 确保src目录包含ModuleName.chtl
2. 确保info目录包含ModuleName.chtl
3. 检查文件名大小写
```

### 调试模式

**启用详细输出：**
```bash
# 设置调试模式
export CHTL_PACKAGE_DEBUG=1

# 运行打包脚本
scripts/linux/package_cmod.sh Chtholly/CMOD/Core
```

**调试输出示例：**
```
[DEBUG] 模块路径: Chtholly/CMOD/Core
[DEBUG] 模块名称: Core
[DEBUG] 临时目录: /tmp/chtl_cmod_package_12345
[DEBUG] 复制src目录...
[DEBUG] 复制info目录...
[DEBUG] 验证文件结构...
[DEBUG] 创建压缩包...
[DEBUG] 清理临时文件...
[INFO] 打包完成: dist/modules/Core.cmod
```

## 📈 统计信息和报告

### 打包统计

**生成打包报告：**
```bash
# 统计打包信息
generate_package_report() {
    local package_file="$1"
    local module_name="$2"
    
    echo "===================="
    echo "模块打包报告"
    echo "===================="
    echo "模块名称: $module_name"
    echo "包文件: $package_file"
    echo "文件大小: $(du -h "$package_file" | cut -f1)"
    echo "创建时间: $(date)"
    
    # 包内容统计
    if command -v unzip >/dev/null 2>&1; then
        echo "包含文件:"
        unzip -l "$package_file" | tail -n +4 | head -n -2
    fi
    
    echo "===================="
}
```

## 📚 相关文档

- [构建脚本说明文档](./构建脚本说明文档.md) - 完整构建流程
- [CHTL语法文档](./CHTL语法文档更新版.md) - 模块语法规范
- [珂朵莉模块使用文档](./珂朵莉模块使用文档.md) - 混合模块示例
- [由比滨结衣模块使用文档](./由比滨结衣模块使用文档.md) - 纯CMOD模块示例
- [项目构建指南](./项目构建指南.md) - 整体构建说明

## 📄 许可证

本打包脚本系统遵循MIT许可证，详见 [LICENSE](../LICENSE) 文件。