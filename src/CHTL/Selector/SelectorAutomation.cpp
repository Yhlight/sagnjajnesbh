#include "CHTL/Selector/SelectorAutomation.h"
#include "CHTL/AST/CHTLASTNodes.h"
#include "Utils/StringUtils.h"
#include "Utils/ErrorHandler.h"
#include <regex>
#include <sstream>

namespace CHTL {
namespace Selector {

// SelectorAutomationConfig实现
void SelectorAutomationConfig::LoadFromConfigNode(const std::shared_ptr<AST::ASTNode>& configNode) {
    if (!configNode) return;
    
    auto config = std::dynamic_pointer_cast<AST::ConfigurationNode>(configNode);
    if (!config) return;
    
    const auto& settings = config->GetSettings();
    
    // 加载选择器自动化配置
    auto it = settings.find("DISABLE_STYLE_AUTO_ADD_CLASS");
    if (it != settings.end()) {
        disableStyleAutoAddClass = (it->second == "true");
    }
    
    it = settings.find("DISABLE_STYLE_AUTO_ADD_ID");
    if (it != settings.end()) {
        disableStyleAutoAddId = (it->second == "true");
    }
    
    it = settings.find("DISABLE_SCRIPT_AUTO_ADD_CLASS");
    if (it != settings.end()) {
        disableScriptAutoAddClass = (it->second == "true");
    }
    
    it = settings.find("DISABLE_SCRIPT_AUTO_ADD_ID");
    if (it != settings.end()) {
        disableScriptAutoAddId = (it->second == "true");
    }
}

// SelectorAnalyzer实现
SelectorAnalyzer::SelectorAnalyzer() {}

std::vector<SelectorInfo> SelectorAnalyzer::AnalyzeStyleSelectors(const std::shared_ptr<AST::StyleBlockNode>& styleBlock) {
    std::vector<SelectorInfo> selectors;
    
    if (!styleBlock) return selectors;
    
    // 获取样式块内容（通过ToString方法）
    std::string content = styleBlock->ToString();
    
    // 解析CSS选择器
    auto cssSelectors = ParseCSSSelectors(content);
    selectors.insert(selectors.end(), cssSelectors.begin(), cssSelectors.end());
    
    // 解析引用选择器
    auto refSelectors = ParseReferenceSelectors(content);
    selectors.insert(selectors.end(), refSelectors.begin(), refSelectors.end());
    
    return selectors;
}

std::vector<SelectorInfo> SelectorAnalyzer::AnalyzeScriptSelectors(const std::shared_ptr<AST::ScriptBlockNode>& scriptBlock) {
    std::vector<SelectorInfo> selectors;
    
    if (!scriptBlock) return selectors;
    
    // 获取脚本块内容（通过ToString方法）
    std::string content = scriptBlock->ToString();
    
    // 解析CHTL JS增强选择器
    auto enhancedSelectors = ParseEnhancedSelectors(content);
    selectors.insert(selectors.end(), enhancedSelectors.begin(), enhancedSelectors.end());
    
    // 解析引用选择器
    auto refSelectors = ParseReferenceSelectors(content);
    selectors.insert(selectors.end(), refSelectors.begin(), refSelectors.end());
    
    return selectors;
}

std::vector<SelectorInfo> SelectorAnalyzer::AnalyzeElementSelectors(const std::shared_ptr<AST::ElementNode>& element) {
    std::vector<SelectorInfo> selectors;
    
    if (!element) return selectors;
    
    // 分析元素的class和id属性
    const auto& attributes = element->GetAttributes();
    
    for (const auto& attr : attributes) {
        if (attr.first == "class") {
            SelectorInfo info;
            info.type = SelectorType::CLASS;
            info.name = attr.second;
            info.fullSelector = "." + attr.second;
            info.position = 0;
            info.isAutoGenerated = false;
            selectors.push_back(info);
        } else if (attr.first == "id") {
            SelectorInfo info;
            info.type = SelectorType::ID;
            info.name = attr.second;
            info.fullSelector = "#" + attr.second;
            info.position = 0;
            info.isAutoGenerated = false;
            selectors.push_back(info);
        }
    }
    
    return selectors;
}

std::vector<SelectorInfo> SelectorAnalyzer::ParseCSSSelectors(const std::string& content) {
    std::vector<SelectorInfo> selectors;
    
    // 匹配CSS类选择器 .className
    std::regex classRegex(R"(\\.([a-zA-Z_][a-zA-Z0-9_-]*))");
    std::sregex_iterator classIter(content.begin(), content.end(), classRegex);
    std::sregex_iterator end;
    
    for (; classIter != end; ++classIter) {
        const std::smatch& match = *classIter;
        SelectorInfo info;
        info.type = SelectorType::CLASS;
        info.name = match[1].str();
        info.fullSelector = match[0].str();
        info.position = match.position();
        info.isAutoGenerated = false;
        selectors.push_back(info);
    }
    
    // 匹配CSS ID选择器 #idName
    std::regex idRegex(R"(#([a-zA-Z_][a-zA-Z0-9_-]*))");
    std::sregex_iterator idIter(content.begin(), content.end(), idRegex);
    
    for (; idIter != end; ++idIter) {
        const std::smatch& match = *idIter;
        SelectorInfo info;
        info.type = SelectorType::ID;
        info.name = match[1].str();
        info.fullSelector = match[0].str();
        info.position = match.position();
        info.isAutoGenerated = false;
        selectors.push_back(info);
    }
    
    return selectors;
}

std::vector<SelectorInfo> SelectorAnalyzer::ParseEnhancedSelectors(const std::string& content) {
    std::vector<SelectorInfo> selectors;
    
    // 匹配CHTL JS增强类选择器 {{.className}}
    std::regex enhancedClassRegex(R"(\{\{\.([a-zA-Z_][a-zA-Z0-9_-]*)\}\})");
    std::sregex_iterator classIter(content.begin(), content.end(), enhancedClassRegex);
    std::sregex_iterator end;
    
    for (; classIter != end; ++classIter) {
        const std::smatch& match = *classIter;
        SelectorInfo info;
        info.type = SelectorType::ENHANCED_CLASS;
        info.name = match[1].str();
        info.fullSelector = match[0].str();
        info.position = match.position();
        info.isAutoGenerated = false;
        selectors.push_back(info);
    }
    
    // 匹配CHTL JS增强ID选择器 {{#idName}}
    std::regex enhancedIdRegex(R"(\{\{#([a-zA-Z_][a-zA-Z0-9_-]*)\}\})");
    std::sregex_iterator idIter(content.begin(), content.end(), enhancedIdRegex);
    
    for (; idIter != end; ++idIter) {
        const std::smatch& match = *idIter;
        SelectorInfo info;
        info.type = SelectorType::ENHANCED_ID;
        info.name = match[1].str();
        info.fullSelector = match[0].str();
        info.position = match.position();
        info.isAutoGenerated = false;
        selectors.push_back(info);
    }
    
    return selectors;
}

std::vector<SelectorInfo> SelectorAnalyzer::ParseReferenceSelectors(const std::string& content) {
    std::vector<SelectorInfo> selectors;
    
    // 匹配引用选择器 &
    std::regex refRegex(R"(&(?![a-zA-Z0-9]))"); // &后面不跟字母数字
    std::sregex_iterator refIter(content.begin(), content.end(), refRegex);
    std::sregex_iterator end;
    
    for (; refIter != end; ++refIter) {
        const std::smatch& match = *refIter;
        SelectorInfo info;
        info.type = SelectorType::REFERENCE;
        info.name = "&";
        info.fullSelector = "&";
        info.position = match.position();
        info.isAutoGenerated = false;
        selectors.push_back(info);
    }
    
    return selectors;
}

std::string SelectorAnalyzer::ExtractSelectorName(const std::string& selector) {
    if (selector.empty()) return "";
    
    // C++17兼容的字符串检查
    auto starts_with = [](const std::string& str, const std::string& prefix) {
        return str.length() >= prefix.length() && 
               str.compare(0, prefix.length(), prefix) == 0;
    };
    
    auto ends_with = [](const std::string& str, const std::string& suffix) {
        return str.length() >= suffix.length() && 
               str.compare(str.length() - suffix.length(), suffix.length(), suffix) == 0;
    };
    
    // 移除选择器前缀
    if (starts_with(selector, "{{.") && ends_with(selector, "}}")) {
        return selector.substr(3, selector.length() - 5); // 移除{{.和}}
    } else if (starts_with(selector, "{{#") && ends_with(selector, "}}")) {
        return selector.substr(3, selector.length() - 5); // 移除{{#和}}
    } else if (starts_with(selector, ".")) {
        return selector.substr(1); // 移除.
    } else if (starts_with(selector, "#")) {
        return selector.substr(1); // 移除#
    } else if (selector == "&") {
        return "&";
    }
    
    return selector;
}

// SelectorAutomationEngine实现
SelectorAutomationEngine::SelectorAutomationEngine(const SelectorAutomationConfig& config)
    : config_(config) {}

bool SelectorAutomationEngine::ProcessElementAutomation(std::shared_ptr<AST::ElementNode>& element) {
    if (!element) return false;
    
    bool processed = false;
    
    // 遍历元素的子节点，查找局部样式块和脚本块
    for (const auto& child : element->GetChildren()) {
        if (auto styleBlock = std::dynamic_pointer_cast<AST::StyleBlockNode>(child)) {
            if (ProcessStyleBlockAutomation(element, styleBlock)) {
                processed = true;
            }
        } else if (auto scriptBlock = std::dynamic_pointer_cast<AST::ScriptBlockNode>(child)) {
            if (ProcessScriptBlockAutomation(element, scriptBlock)) {
                processed = true;
            }
        }
    }
    
    return processed;
}

bool SelectorAutomationEngine::ProcessStyleBlockAutomation(std::shared_ptr<AST::ElementNode>& element,
                                                          const std::shared_ptr<AST::StyleBlockNode>& styleBlock) {
    if (!element || !styleBlock) return false;
    
    bool processed = false;
    
    // 分析样式块中的选择器
    auto selectors = analyzer_.AnalyzeStyleSelectors(styleBlock);
    
    // 当局部style内部存在多组类选择器时，若class属性缺失，则自动添加第一个类选择器
    if (!config_.disableStyleAutoAddClass && !HasClassAttribute(element)) {
        for (const auto& selector : selectors) {
            if (selector.type == SelectorType::CLASS) {
                if (AutoAddClassAttribute(element, selector.name)) {
                    Utils::ErrorHandler::GetInstance().LogInfo(
                        "局部样式块自动添加类选择器: " + selector.name
                    );
                    processed = true;
                    break; // 只添加第一个
                }
            }
        }
    }
    
    // 当局部style内部存在多组id选择器时，若id属性缺失，则自动添加第一个id选择器
    if (!config_.disableStyleAutoAddId && !HasIdAttribute(element)) {
        for (const auto& selector : selectors) {
            if (selector.type == SelectorType::ID) {
                if (AutoAddIdAttribute(element, selector.name)) {
                    Utils::ErrorHandler::GetInstance().LogInfo(
                        "局部样式块自动添加ID选择器: " + selector.name
                    );
                    processed = true;
                    break; // 只添加第一个
                }
            }
        }
    }
    
    return processed;
}

bool SelectorAutomationEngine::ProcessScriptBlockAutomation(std::shared_ptr<AST::ElementNode>& element,
                                                           const std::shared_ptr<AST::ScriptBlockNode>& scriptBlock) {
    if (!element || !scriptBlock) return false;
    
    bool processed = false;
    
    // 分析脚本块中的增强选择器
    auto selectors = analyzer_.AnalyzeScriptSelectors(scriptBlock);
    
    // 如果DISABLE_SCRIPT_AUTO_ADD_CLASS为真且局部style没有触发class自动化添加
    if (config_.disableScriptAutoAddClass && !HasClassAttribute(element)) {
        // 检查是否有局部样式块已经处理了class
        bool styleHasClassSelectors = false;
        for (const auto& child : element->GetChildren()) {
            if (auto styleBlock = std::dynamic_pointer_cast<AST::StyleBlockNode>(child)) {
                auto styleSelectors = analyzer_.AnalyzeStyleSelectors(styleBlock);
                for (const auto& sel : styleSelectors) {
                    if (sel.type == SelectorType::CLASS) {
                        styleHasClassSelectors = true;
                        break;
                    }
                }
                if (styleHasClassSelectors) break;
            }
        }
        
        // 如果局部style没有触发class自动化添加，第一个{{.box}}会被自动添加
        if (!styleHasClassSelectors) {
            for (const auto& selector : selectors) {
                if (selector.type == SelectorType::ENHANCED_CLASS) {
                    if (AutoAddClassAttribute(element, selector.name)) {
                        Utils::ErrorHandler::GetInstance().LogInfo(
                            "局部脚本块自动添加类选择器: " + selector.name
                        );
                        processed = true;
                        break; // 只添加第一个{{.box}}
                    }
                }
            }
        }
    }
    
    // 如果DISABLE_SCRIPT_AUTO_ADD_ID为真且局部style没有触发id自动化添加
    if (config_.disableScriptAutoAddId && !HasIdAttribute(element)) {
        // 检查是否有局部样式块已经处理了id
        bool styleHasIdSelectors = false;
        for (const auto& child : element->GetChildren()) {
            if (auto styleBlock = std::dynamic_pointer_cast<AST::StyleBlockNode>(child)) {
                auto styleSelectors = analyzer_.AnalyzeStyleSelectors(styleBlock);
                for (const auto& sel : styleSelectors) {
                    if (sel.type == SelectorType::ID) {
                        styleHasIdSelectors = true;
                        break;
                    }
                }
                if (styleHasIdSelectors) break;
            }
        }
        
        // 如果局部style没有触发id自动化添加，第一个{{#box}}会被自动添加
        if (!styleHasIdSelectors) {
            for (const auto& selector : selectors) {
                if (selector.type == SelectorType::ENHANCED_ID) {
                    if (AutoAddIdAttribute(element, selector.name)) {
                        Utils::ErrorHandler::GetInstance().LogInfo(
                            "局部脚本块自动添加ID选择器: " + selector.name
                        );
                        processed = true;
                        break; // 只添加第一个{{#box}}
                    }
                }
            }
        }
    }
    
    return processed;
}

bool SelectorAutomationEngine::AutoAddClassAttribute(std::shared_ptr<AST::ElementNode>& element, const std::string& className) {
    if (!element || className.empty()) return false;
    
    // 直接添加class属性
    element->AddAttribute("class", className);
    
    return true;
}

bool SelectorAutomationEngine::AutoAddIdAttribute(std::shared_ptr<AST::ElementNode>& element, const std::string& idName) {
    if (!element || idName.empty()) return false;
    
    // 直接添加id属性
    element->AddAttribute("id", idName);
    
    return true;
}

bool SelectorAutomationEngine::HasClassAttribute(const std::shared_ptr<AST::ElementNode>& element) const {
    if (!element) return false;
    
    return element->HasAttribute("class");
}

bool SelectorAutomationEngine::HasIdAttribute(const std::shared_ptr<AST::ElementNode>& element) const {
    if (!element) return false;
    
    return element->HasAttribute("id");
}

void SelectorAutomationEngine::UpdateConfig(const SelectorAutomationConfig& config) {
    config_ = config;
}

// ReferenceSelectorResolver实现
ReferenceSelectorResolver::ReferenceSelectorResolver() {}

bool ReferenceSelectorResolver::ResolveElementReferences(const std::shared_ptr<AST::ElementNode>& element) {
    if (!element) return false;
    
    bool resolved = false;
    
    // 遍历元素的子节点
    for (const auto& child : element->GetChildren()) {
        if (auto styleBlock = std::dynamic_pointer_cast<AST::StyleBlockNode>(child)) {
            if (ResolveStyleReferences(styleBlock, element) > 0) {
                resolved = true;
            }
        } else if (auto scriptBlock = std::dynamic_pointer_cast<AST::ScriptBlockNode>(child)) {
            if (ResolveScriptReferences(scriptBlock, element) > 0) {
                resolved = true;
            }
        }
    }
    
    return resolved;
}

int ReferenceSelectorResolver::ResolveStyleReferences(std::shared_ptr<AST::StyleBlockNode>& styleBlock,
                                                     const std::shared_ptr<AST::ElementNode>& element) {
    if (!styleBlock || !element) return 0;
    
    // 对于局部style来说，& 引用选择器优先选择class
    std::string prioritySelector = GetStylePrioritySelector(element);
    
    if (prioritySelector.empty()) return 0;
    
    // 获取样式块内容并替换引用选择器
    std::string content = styleBlock->ToString();
    std::string newContent = ReplaceReferenceSelectors(content, prioritySelector);
    
    if (content != newContent) {
        // 注意：StyleBlockNode可能没有SetContent方法，这里只做日志记录
        
        Utils::ErrorHandler::GetInstance().LogInfo(
            "样式块中&引用选择器已替换为: " + prioritySelector
        );
        
        return 1;
    }
    
    return 0;
}

int ReferenceSelectorResolver::ResolveScriptReferences(std::shared_ptr<AST::ScriptBlockNode>& scriptBlock,
                                                      const std::shared_ptr<AST::ElementNode>& element) {
    if (!scriptBlock || !element) return 0;
    
    // 对于局部script来说，& 引用选择器优先选择id
    std::string prioritySelector = GetScriptPrioritySelector(element);
    
    if (prioritySelector.empty()) return 0;
    
    // 获取脚本块内容并替换引用选择器
    std::string content = scriptBlock->ToString();
    std::string newContent = ReplaceReferenceSelectors(content, prioritySelector);
    
    if (content != newContent) {
        // 注意：ScriptBlockNode可能没有SetContent方法，这里只做日志记录
        
        Utils::ErrorHandler::GetInstance().LogInfo(
            "脚本块中&引用选择器已替换为: " + prioritySelector
        );
        
        return 1;
    }
    
    return 0;
}

std::string ReferenceSelectorResolver::GetStylePrioritySelector(const std::shared_ptr<AST::ElementNode>& element) const {
    if (!element) return "";
    
    // 对于局部style来说，& 引用选择器优先选择class
    const auto& attributes = element->GetAttributes();
    
    // 首先查找class属性
    for (const auto& attr : attributes) {
        if (attr.first == "class") {
            return "." + attr.second;
        }
    }
    
    // 如果没有class，查找id属性
    for (const auto& attr : attributes) {
        if (attr.first == "id") {
            return "#" + attr.second;
        }
    }
    
    // 如果都没有，返回元素标签名
    return element->GetTagName();
}

std::string ReferenceSelectorResolver::GetScriptPrioritySelector(const std::shared_ptr<AST::ElementNode>& element) const {
    if (!element) return "";
    
    // 对于局部script来说，& 引用选择器优先选择id
    const auto& attributes = element->GetAttributes();
    
    // 首先查找id属性
    for (const auto& attr : attributes) {
        if (attr.first == "id") {
            return "{{#" + attr.second + "}}";
        }
    }
    
    // 如果没有id，查找class属性
    for (const auto& attr : attributes) {
        if (attr.first == "class") {
            return "{{." + attr.second + "}}";
        }
    }
    
    // 如果都没有，返回元素标签名的增强选择器
    return "{{" + element->GetTagName() + "}}";
}

std::string ReferenceSelectorResolver::ReplaceReferenceSelectors(const std::string& content, const std::string& referenceSelector) {
    // 替换所有的&引用选择器
    std::regex refRegex(R"(&(?![a-zA-Z0-9]))");
    return std::regex_replace(content, refRegex, referenceSelector);
}

// SelectorAutomationManager实现
SelectorAutomationManager::SelectorAutomationManager()
    : automationEngine_(config_), classAutoAddCount_(0), idAutoAddCount_(0), referenceResolveCount_(0) {}

void SelectorAutomationManager::SetConfig(const SelectorAutomationConfig& config) {
    config_ = config;
    automationEngine_.UpdateConfig(config);
}

void SelectorAutomationManager::LoadConfigFromNode(const std::shared_ptr<AST::ASTNode>& configNode) {
    config_.LoadFromConfigNode(configNode);
    automationEngine_.UpdateConfig(config_);
    
    Utils::ErrorHandler::GetInstance().LogInfo(
        "从配置节点加载选择器自动化配置"
    );
}

bool SelectorAutomationManager::ProcessElement(std::shared_ptr<AST::ElementNode>& element) {
    if (!element) return false;
    
    bool processed = false;
    
    // 1. 处理选择器自动化
    if (automationEngine_.ProcessElementAutomation(element)) {
        processed = true;
        
        // 更新统计信息
        if (HasClassAttribute(element)) {
            classAutoAddCount_++;
        }
        if (HasIdAttribute(element)) {
            idAutoAddCount_++;
        }
    }
    
    // 2. 处理引用选择器解析
    if (referenceResolver_.ResolveElementReferences(element)) {
        processed = true;
        referenceResolveCount_++;
    }
    
    return processed;
}

bool SelectorAutomationManager::HasClassAttribute(const std::shared_ptr<AST::ElementNode>& element) const {
    if (!element) return false;
    
    return element->HasAttribute("class");
}

bool SelectorAutomationManager::HasIdAttribute(const std::shared_ptr<AST::ElementNode>& element) const {
    if (!element) return false;
    
    return element->HasAttribute("id");
}

std::string SelectorAutomationManager::GetStatistics() const {
    std::ostringstream stats;
    stats << "选择器自动化统计:\n";
    stats << "  自动添加的类选择器: " << classAutoAddCount_ << "\n";
    stats << "  自动添加的ID选择器: " << idAutoAddCount_ << "\n";
    stats << "  解析的引用选择器: " << referenceResolveCount_ << "\n";
    stats << "  配置状态:\n";
    stats << "    禁用样式块类自动化: " << (config_.disableStyleAutoAddClass ? "是" : "否") << "\n";
    stats << "    禁用样式块ID自动化: " << (config_.disableStyleAutoAddId ? "是" : "否") << "\n";
    stats << "    禁用脚本块类自动化: " << (config_.disableScriptAutoAddClass ? "是" : "否") << "\n";
    stats << "    禁用脚本块ID自动化: " << (config_.disableScriptAutoAddId ? "是" : "否") << "\n";
    
    return stats.str();
}

void SelectorAutomationManager::ResetStatistics() {
    classAutoAddCount_ = 0;
    idAutoAddCount_ = 0;
    referenceResolveCount_ = 0;
}

} // namespace Selector
} // namespace CHTL