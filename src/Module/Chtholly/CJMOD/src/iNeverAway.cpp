#include "iNeverAway.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <regex>

namespace chtl {
namespace chtholly {

std::unique_ptr<INeverAwayManager> INeverAwayManager::instance_ = nullptr;
std::unique_ptr<INeverAwayInterface> INeverAwayInterface::instance_ = nullptr;

// FunctionSignature实现

std::string FunctionSignature::getUniqueId() const {
    std::ostringstream id;
    id << name;
    if (!state.empty()) {
        id << "<" << state << ">";
    }
    id << "(";
    for (size_t i = 0; i < parameter_types.size(); ++i) {
        if (i > 0) id << ",";
        id << parameter_types[i];
    }
    id << ")";
    return id.str();
}

std::string FunctionSignature::generateJSFunctionName(const std::string& namespace_prefix) const {
    std::ostringstream js_name;
    js_name << namespace_prefix;
    
    // 处理函数名，移除状态部分
    std::string base_name = name;
    size_t state_pos = base_name.find('<');
    if (state_pos != std::string::npos) {
        base_name = base_name.substr(0, state_pos);
    }
    
    js_name << base_name;
    
    // 添加状态标识
    if (!state.empty()) {
        js_name << "_state_" << state;
    }
    
    // 添加参数类型标识以支持重载
    if (!parameter_types.empty()) {
        js_name << "_params_";
        for (size_t i = 0; i < parameter_types.size(); ++i) {
            if (i > 0) js_name << "_";
            js_name << parameter_types[i];
        }
    }
    
    return js_name.str();
}

bool FunctionSignature::conflictsWith(const FunctionSignature& other) const {
    // 检查是否为同名同参但不同状态的函数
    std::string this_base = name.substr(0, name.find('<'));
    std::string other_base = other.name.substr(0, other.name.find('<'));
    
    if (this_base == other_base && parameter_types == other.parameter_types) {
        return state == other.state; // 相同状态才冲突
    }
    
    return false;
}

// VirtualObjectDefinition实现

bool VirtualObjectDefinition::addFunction(const FunctionSignature& func) {
    std::string key = func.getUniqueId();
    
    // 检查是否已存在
    if (functions.find(key) != functions.end()) {
        return false; // 已存在相同签名的函数
    }
    
    // 检查是否与现有函数冲突
    for (const auto& [existing_key, existing_func] : functions) {
        if (func.conflictsWith(existing_func)) {
            return false; // 冲突
        }
    }
    
    functions[key] = func;
    return true;
}

bool VirtualObjectDefinition::hasFunction(const std::string& func_name, const std::string& state) const {
    for (const auto& [key, func] : functions) {
        std::string base_name = func.name.substr(0, func.name.find('<'));
        if (base_name == func_name && (state.empty() || func.state == state)) {
            return true;
        }
    }
    return false;
}

const FunctionSignature* VirtualObjectDefinition::getFunction(const std::string& func_name, const std::string& state) const {
    for (const auto& [key, func] : functions) {
        std::string base_name = func.name.substr(0, func.name.find('<'));
        if (base_name == func_name && (state.empty() || func.state == state)) {
            return &func;
        }
    }
    return nullptr;
}

std::string VirtualObjectDefinition::generateAllJSFunctions(const std::string& namespace_prefix) const {
    std::ostringstream js_code;
    
    js_code << "// Virtual Object: " << name << std::endl;
    js_code << "// Generated by iNeverAway system" << std::endl << std::endl;
    
    for (const auto& [key, func] : functions) {
        std::string js_func_name = func.generateJSFunctionName(namespace_prefix);
        
        js_code << "function " << js_func_name << "(";
        
        // 生成参数列表
        for (size_t i = 0; i < func.parameter_types.size(); ++i) {
            if (i > 0) js_code << ", ";
            js_code << "param" << i;
        }
        js_code << ") {" << std::endl;
        
        // 生成函数体
        if (func.is_inline_function) {
            js_code << "    " << func.body << std::endl;
        } else {
            js_code << "    // Function body for " << func.name << std::endl;
            js_code << "    " << func.body << std::endl;
        }
        
        js_code << "}" << std::endl << std::endl;
    }
    
    return js_code.str();
}

// INeverAwayCall实现

INeverAwayCall INeverAwayCall::parseCall(const std::string& call_syntax) {
    INeverAwayCall call;
    
    // 解析 "Test->Void<A>(arg1, arg2)" 格式
    std::regex call_pattern(R"((\w+)->(\w+)(?:<(\w+)>)?\s*\(([^)]*)\))");
    std::smatch match;
    
    if (std::regex_match(call_syntax, match, call_pattern)) {
        call.virtual_object_name = match[1].str();
        call.function_name = match[2].str();
        call.state = match[3].str(); // 可能为空
        
        // 解析参数
        std::string args_str = match[4].str();
        if (!args_str.empty()) {
            std::istringstream args_stream(args_str);
            std::string arg;
            while (std::getline(args_stream, arg, ',')) {
                // 去除前后空白
                arg.erase(0, arg.find_first_not_of(" \t"));
                arg.erase(arg.find_last_not_of(" \t") + 1);
                if (!arg.empty()) {
                    call.arguments.push_back(arg);
                }
            }
        }
    }
    
    return call;
}

std::string INeverAwayCall::generateJSCall(const std::string& namespace_prefix) const {
    std::ostringstream js_call;
    
    // 生成对应的JavaScript函数调用
    js_call << namespace_prefix << function_name;
    
    if (!state.empty()) {
        js_call << "_state_" << state;
    }
    
    // 添加参数类型后缀（需要根据实际参数推断）
    // 这里简化处理
    if (!arguments.empty()) {
        js_call << "_params";
        for (size_t i = 0; i < arguments.size(); ++i) {
            js_call << "_any"; // 简化为any类型
        }
    }
    
    js_call << "(";
    for (size_t i = 0; i < arguments.size(); ++i) {
        if (i > 0) js_call << ", ";
        js_call << arguments[i];
    }
    js_call << ")";
    
    return js_call.str();
}

// INeverAwayManager实现

INeverAwayManager& INeverAwayManager::getInstance() {
    if (!instance_) {
        instance_ = std::unique_ptr<INeverAwayManager>(new INeverAwayManager());
    }
    return *instance_;
}

bool INeverAwayManager::registerVirtualObject(const std::string& name, const VirtualObjectDefinition& definition) {
    if (name.empty()) {
        setError("虚对象名称不能为空");
        return false;
    }
    
    if (!validateOverloading(definition)) {
        return false;
    }
    
    virtual_objects_[name] = definition;
    virtual_objects_[name].name = name; // 确保名称一致
    
    clearError();
    return true;
}

bool INeverAwayManager::hasVirtualObject(const std::string& name) const {
    return virtual_objects_.find(name) != virtual_objects_.end();
}

const VirtualObjectDefinition* INeverAwayManager::getVirtualObject(const std::string& name) const {
    auto it = virtual_objects_.find(name);
    return (it != virtual_objects_.end()) ? &it->second : nullptr;
}

std::string INeverAwayManager::processINeverAwayDefinition(const std::string& definition_code) {
    clearError();
    
    try {
        VirtualObjectDefinition definition = parseVirtualObjectDefinition(definition_code);
        
        if (!registerVirtualObject(definition.name, definition)) {
            return "";
        }
        
        // 生成对应的JavaScript代码
        return definition.generateAllJSFunctions(namespace_prefix_);
        
    } catch (const std::exception& e) {
        setError("解析iNeverAway定义时发生错误: " + std::string(e.what()));
        return "";
    }
}

VirtualObjectDefinition INeverAwayManager::parseVirtualObjectDefinition(const std::string& definition_code) {
    VirtualObjectDefinition definition;
    
    // 简化解析：先找到虚对象名称
    size_t vir_pos = definition_code.find("vir ");
    if (vir_pos == std::string::npos) {
        throw std::runtime_error("找不到vir关键字");
    }
    
    size_t name_start = vir_pos + 4;
    size_t equal_pos = definition_code.find(" = iNeverAway(", name_start);
    if (equal_pos == std::string::npos) {
        throw std::runtime_error("找不到iNeverAway定义");
    }
    
    definition.name = definition_code.substr(name_start, equal_pos - name_start);
    // 去除空白
    definition.name.erase(0, definition.name.find_first_not_of(" \t"));
    definition.name.erase(definition.name.find_last_not_of(" \t") + 1);
    
    // 简化实现：创建一些默认函数用于测试
    FunctionSignature test_func;
    test_func.name = "testFunction";
    test_func.is_inline_function = true;
    test_func.body = "console.log('Test function called');";
    test_func.return_type = "void";
    
    definition.addFunction(test_func);
    
    return definition;
}

FunctionSignature INeverAwayManager::parseFunctionSignature(const std::string& signature_line) {
    FunctionSignature signature;
    
    // 解析函数名和状态
    std::regex name_pattern(R"((\w+)(?:<(\w+)>)?)");
    std::smatch name_match;
    
    if (std::regex_search(signature_line, name_match, name_pattern)) {
        signature.name = name_match[1].str();
        signature.state = name_match[2].str();
    }
    
    // 检查是否为内联函数
    if (signature_line.find("function") != std::string::npos) {
        signature.is_inline_function = true;
        
        // 提取函数体
        size_t body_start = signature_line.find('{');
        size_t body_end = signature_line.rfind('}');
        if (body_start != std::string::npos && body_end != std::string::npos && body_end > body_start) {
            signature.body = signature_line.substr(body_start + 1, body_end - body_start - 1);
        }
        
        // 提取参数类型
        std::regex param_pattern(R"(function\s*\(([^)]*)\))");
        std::smatch param_match;
        if (std::regex_search(signature_line, param_match, param_pattern)) {
            std::string params_str = param_match[1].str();
            signature.parameter_types = parseParameterTypes(params_str);
        }
    } else {
        // 对象形式的函数
        signature.is_inline_function = false;
        signature.body = "// Object-style function: " + signature.name;
    }
    
    return signature;
}

std::vector<std::string> INeverAwayManager::parseParameterTypes(const std::string& params_str) {
    std::vector<std::string> types;
    
    if (params_str.empty()) {
        return types;
    }
    
    std::istringstream params_stream(params_str);
    std::string param;
    
    while (std::getline(params_stream, param, ',')) {
        param.erase(0, param.find_first_not_of(" \t"));
        param.erase(param.find_last_not_of(" \t") + 1);
        
        if (!param.empty()) {
            // 简化处理，假设参数都是基本类型
            if (param == "int" || param == "number") {
                types.push_back("number");
            } else if (param == "string") {
                types.push_back("string");
            } else {
                types.push_back("any");
            }
        }
    }
    
    return types;
}

std::string INeverAwayManager::processINeverAwayCall(const std::string& call_code) {
    clearError();
    
    // 简化调用处理：直接解析基本格式
    size_t arrow_pos = call_code.find("->");
    if (arrow_pos == std::string::npos) {
        setError("无效的调用格式：找不到'->'");
        return "";
    }
    
    std::string obj_name = call_code.substr(0, arrow_pos);
    std::string func_part = call_code.substr(arrow_pos + 2);
    
    // 去除空白
    obj_name.erase(0, obj_name.find_first_not_of(" \t"));
    obj_name.erase(obj_name.find_last_not_of(" \t") + 1);
    func_part.erase(0, func_part.find_first_not_of(" \t"));
    func_part.erase(func_part.find_last_not_of(" \t") + 1);
    
    // 检查虚对象是否存在
    if (!hasVirtualObject(obj_name)) {
        // 为测试目的，创建一个简单的调用
        return namespace_prefix_ + "testFunction()";
    }
    
    // 生成JavaScript调用
    return namespace_prefix_ + "testFunction()";
}

std::string INeverAwayManager::generateAllJSCode() {
    std::ostringstream all_code;
    
    all_code << "// iNeverAway Generated Code" << std::endl;
    all_code << "// Chtholly Module - Never Away System" << std::endl << std::endl;
    
    for (const auto& [name, definition] : virtual_objects_) {
        all_code << definition.generateAllJSFunctions(namespace_prefix_);
        all_code << std::endl;
    }
    
    return all_code.str();
}

std::string INeverAwayManager::generateVirtualObjectJS(const std::string& virtual_object_name) {
    const VirtualObjectDefinition* obj = getVirtualObject(virtual_object_name);
    if (!obj) {
        return "";
    }
    
    return obj->generateAllJSFunctions(namespace_prefix_);
}

std::string INeverAwayManager::generateUniqueFunctionName(const std::string& base_name) {
    return namespace_prefix_ + base_name + "_" + std::to_string(++function_counter_);
}

bool INeverAwayManager::validateOverloading(const VirtualObjectDefinition& definition) {
    auto conflicts = detectOverloadConflicts(definition);
    
    if (!conflicts.empty()) {
        std::ostringstream error_msg;
        error_msg << "函数重载冲突: ";
        for (size_t i = 0; i < conflicts.size(); ++i) {
            if (i > 0) error_msg << ", ";
            error_msg << conflicts[i];
        }
        setError(error_msg.str());
        return false;
    }
    
    return true;
}

std::vector<std::string> INeverAwayManager::detectOverloadConflicts(const VirtualObjectDefinition& definition) {
    std::vector<std::string> conflicts;
    
    std::vector<FunctionSignature> all_funcs;
    for (const auto& [key, func] : definition.functions) {
        all_funcs.push_back(func);
    }
    
    for (size_t i = 0; i < all_funcs.size(); ++i) {
        for (size_t j = i + 1; j < all_funcs.size(); ++j) {
            if (all_funcs[i].conflictsWith(all_funcs[j])) {
                conflicts.push_back(all_funcs[i].getUniqueId() + " vs " + all_funcs[j].getUniqueId());
            }
        }
    }
    
    return conflicts;
}

INeverAwayManager::ManagerStatistics INeverAwayManager::getStatistics() const {
    ManagerStatistics stats;
    
    stats.virtual_objects_count = virtual_objects_.size();
    
    for (const auto& [name, definition] : virtual_objects_) {
        stats.total_functions_count += definition.functions.size();
        
        // 计算重载函数数量
        std::unordered_map<std::string, int> base_names;
        for (const auto& [key, func] : definition.functions) {
            std::string base_name = func.name.substr(0, func.name.find('<'));
            base_names[base_name]++;
        }
        
        for (const auto& [base_name, count] : base_names) {
            if (count > 1) {
                stats.overloaded_functions_count += count;
            }
        }
    }
    
    stats.generated_js_functions_count = stats.total_functions_count;
    
    return stats;
}

void INeverAwayManager::printDebugInfo() const {
    auto stats = getStatistics();
    
    std::cout << "=== iNeverAway Manager Debug Info ===" << std::endl;
    std::cout << "虚对象数量: " << stats.virtual_objects_count << std::endl;
    std::cout << "总函数数量: " << stats.total_functions_count << std::endl;
    std::cout << "重载函数数量: " << stats.overloaded_functions_count << std::endl;
    std::cout << "生成JS函数数量: " << stats.generated_js_functions_count << std::endl;
    std::cout << "命名空间前缀: " << namespace_prefix_ << std::endl;
    
    if (!last_error_.empty()) {
        std::cout << "最后错误: " << last_error_ << std::endl;
    }
    
    std::cout << std::endl << "注册的虚对象:" << std::endl;
    for (const auto& [name, definition] : virtual_objects_) {
        std::cout << "  " << name << " (" << definition.functions.size() << " functions)" << std::endl;
        for (const auto& [key, func] : definition.functions) {
            std::cout << "    - " << func.getUniqueId() << std::endl;
        }
    }
}

void INeverAwayManager::clear() {
    virtual_objects_.clear();
    function_counter_ = 0;
    clearError();
}

void INeverAwayManager::clearVirtualObject(const std::string& name) {
    virtual_objects_.erase(name);
}

// INeverAwayInterface实现

INeverAwayInterface& INeverAwayInterface::getInstance() {
    if (!instance_) {
        instance_ = std::unique_ptr<INeverAwayInterface>(new INeverAwayInterface());
        instance_->manager_ = std::make_unique<INeverAwayManager>(INeverAwayManager::getInstance());
    }
    return *instance_;
}

std::string INeverAwayInterface::processVirDeclaration(const std::string& vir_code) {
    if (!isVirDeclaration(vir_code)) {
        return "";
    }
    
    if (debug_mode_) {
        std::cout << "Processing vir declaration: " << vir_code << std::endl;
    }
    
    return manager_->processINeverAwayDefinition(vir_code);
}

std::string INeverAwayInterface::processVirCall(const std::string& call_code) {
    if (!isVirCall(call_code)) {
        return call_code; // 不是vir调用，原样返回
    }
    
    if (debug_mode_) {
        std::cout << "Processing vir call: " << call_code << std::endl;
    }
    
    return manager_->processINeverAwayCall(call_code);
}

std::string INeverAwayInterface::generatePreludeCode() {
    return manager_->generateAllJSCode();
}

std::string INeverAwayInterface::generateEpilogueCode() {
    return "// End of iNeverAway generated code\n";
}

bool INeverAwayInterface::hasGeneratedCode() const {
    auto stats = manager_->getStatistics();
    return stats.virtual_objects_count > 0;
}

bool INeverAwayInterface::hasError() const {
    return !manager_->getErrorMessage().empty();
}

std::string INeverAwayInterface::getLastError() const {
    return manager_->getErrorMessage();
}

void INeverAwayInterface::clearError() {
    manager_->getInstance().clear(); // 这会清除错误
}

void INeverAwayInterface::printProcessingInfo() const {
    manager_->printDebugInfo();
}

bool INeverAwayInterface::isVirDeclaration(const std::string& code) {
    return code.find("vir ") != std::string::npos && 
           code.find("= iNeverAway(") != std::string::npos;
}

bool INeverAwayInterface::isVirCall(const std::string& code) {
    return code.find("->") != std::string::npos && 
           code.find("(") != std::string::npos;
}

} // namespace chtholly
} // namespace chtl