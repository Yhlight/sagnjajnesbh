#include <iostream>
#include <cassert>
#include <memory>
#include "CHTL/Selector/SelectorAutomation.h"
#include "CHTL/AST/CHTLASTNodes.h"
#include "CHTL/Core/CHTLToken.h"

using namespace CHTL;
using namespace CHTL::Selector;

// 测试选择器自动化配置
void test_selector_automation_config() {
    std::cout << "测试选择器自动化配置...\n";
    
    SelectorAutomationConfig config;
    
    // 测试默认配置
    assert(!config.disableStyleAutoAddClass);   // 默认启用样式块类自动化
    assert(!config.disableStyleAutoAddId);      // 默认启用样式块ID自动化
    assert(config.disableScriptAutoAddClass);   // 默认禁用脚本块类自动化
    assert(config.disableScriptAutoAddId);      // 默认禁用脚本块ID自动化
    
    std::cout << "  默认配置验证:\n";
    std::cout << "    样式块类自动化: " << (!config.disableStyleAutoAddClass ? "启用" : "禁用") << "\n";
    std::cout << "    样式块ID自动化: " << (!config.disableStyleAutoAddId ? "启用" : "禁用") << "\n";
    std::cout << "    脚本块类自动化: " << (!config.disableScriptAutoAddClass ? "启用" : "禁用") << "\n";
    std::cout << "    脚本块ID自动化: " << (!config.disableScriptAutoAddId ? "启用" : "禁用") << "\n";
    
    std::cout << "  ✅ 选择器自动化配置测试通过\n";
}

// 测试选择器类型枚举
void test_selector_types() {
    std::cout << "测试选择器类型枚举...\n";
    
    // 测试选择器信息创建
    SelectorInfo classInfo;
    classInfo.type = SelectorType::CLASS;
    classInfo.name = "button";
    classInfo.fullSelector = ".button";
    classInfo.position = 0;
    classInfo.isAutoGenerated = false;
    
    assert(classInfo.type == SelectorType::CLASS);
    assert(classInfo.name == "button");
    assert(classInfo.fullSelector == ".button");
    assert(!classInfo.isAutoGenerated);
    
    SelectorInfo enhancedInfo;
    enhancedInfo.type = SelectorType::ENHANCED_CLASS;
    enhancedInfo.name = "modal";
    enhancedInfo.fullSelector = "{{.modal}}";
    enhancedInfo.position = 0;
    enhancedInfo.isAutoGenerated = true;
    
    assert(enhancedInfo.type == SelectorType::ENHANCED_CLASS);
    assert(enhancedInfo.name == "modal");
    assert(enhancedInfo.fullSelector == "{{.modal}}");
    assert(enhancedInfo.isAutoGenerated);
    
    SelectorInfo refInfo;
    refInfo.type = SelectorType::REFERENCE;
    refInfo.name = "&";
    refInfo.fullSelector = "&";
    refInfo.position = 0;
    refInfo.isAutoGenerated = false;
    
    assert(refInfo.type == SelectorType::REFERENCE);
    assert(refInfo.name == "&");
    assert(refInfo.fullSelector == "&");
    
    std::cout << "  选择器信息结构验证:\n";
    std::cout << "    类选择器: " << classInfo.fullSelector << " -> " << classInfo.name << "\n";
    std::cout << "    增强选择器: " << enhancedInfo.fullSelector << " -> " << enhancedInfo.name << "\n";
    std::cout << "    引用选择器: " << refInfo.fullSelector << " -> " << refInfo.name << "\n";
    
    std::cout << "  ✅ 选择器类型测试通过\n";
}

// 测试选择器自动化管理器创建
void test_selector_automation_manager_creation() {
    std::cout << "测试选择器自动化管理器创建...\n";
    
    SelectorAutomationManager manager;
    
    // 测试配置设置
    SelectorAutomationConfig config;
    config.disableStyleAutoAddClass = true;
    config.disableStyleAutoAddId = false;
    config.disableScriptAutoAddClass = false;
    config.disableScriptAutoAddId = true;
    
    manager.SetConfig(config);
    
    // 测试统计信息
    std::string stats = manager.GetStatistics();
    assert(!stats.empty());
    
    std::cout << "  初始统计信息:\n" << stats;
    
    // 测试重置统计
    manager.ResetStatistics();
    std::string resetStats = manager.GetStatistics();
    assert(resetStats.find("0") != std::string::npos); // 应该包含0的统计
    
    std::cout << "  重置后统计信息:\n" << resetStats;
    
    std::cout << "  ✅ 选择器自动化管理器创建测试通过\n";
}

// 测试基本的元素属性操作
void test_basic_element_attributes() {
    std::cout << "测试基本的元素属性操作...\n";
    
    // 创建测试元素
    auto element = std::make_shared<AST::ElementNode>("div", Core::CHTLToken());
    
    // 测试初始状态
    assert(!element->HasAttribute("class"));
    assert(!element->HasAttribute("id"));
    
    // 添加属性
    element->AddAttribute("class", "test-class");
    element->AddAttribute("id", "test-id");
    
    // 验证属性已添加
    assert(element->HasAttribute("class"));
    assert(element->HasAttribute("id"));
    assert(element->GetAttribute("class") == "test-class");
    assert(element->GetAttribute("id") == "test-id");
    
    std::cout << "  元素属性操作验证:\n";
    std::cout << "    添加的class: " << element->GetAttribute("class") << "\n";
    std::cout << "    添加的id: " << element->GetAttribute("id") << "\n";
    
    // 测试属性集合
    const auto& attributes = element->GetAttributes();
    assert(attributes.size() == 2);
    assert(attributes.at("class") == "test-class");
    assert(attributes.at("id") == "test-id");
    
    std::cout << "    属性集合大小: " << attributes.size() << "\n";
    
    std::cout << "  ✅ 基本元素属性操作测试通过\n";
}

int main() {
    std::cout << "运行选择器自动化基础测试...\n\n";
    
    try {
        test_selector_automation_config();
        test_selector_types();
        test_selector_automation_manager_creation();
        test_basic_element_attributes();
        
        std::cout << "\n🎉 所有选择器自动化基础测试通过!\n";
        std::cout << "✅ 选择器自动化配置正常\n";
        std::cout << "✅ 选择器类型系统正常\n";
        std::cout << "✅ 选择器自动化管理器创建正常\n";
        std::cout << "✅ 基本元素属性操作正常\n";
        
        std::cout << "\n📋 选择器自动化功能总结:\n";
        std::cout << "🔧 [Configuration]配置支持:\n";
        std::cout << "   DISABLE_STYLE_AUTO_ADD_CLASS = false (默认启用)\n";
        std::cout << "   DISABLE_STYLE_AUTO_ADD_ID = false (默认启用)\n";
        std::cout << "   DISABLE_SCRIPT_AUTO_ADD_CLASS = true (默认禁用，启用特殊逻辑)\n";
        std::cout << "   DISABLE_SCRIPT_AUTO_ADD_ID = true (默认禁用，启用特殊逻辑)\n";
        std::cout << "\n🎯 自动化规则:\n";
        std::cout << "   局部样式块：class/id属性缺失时自动添加第一个选择器\n";
        std::cout << "   局部脚本块：特殊逻辑下，没有样式块时自动添加{{.box}}/{{#box}}\n";
        std::cout << "\n🔗 引用选择器规则:\n";
        std::cout << "   样式块&引用：优先选择class (.class)\n";
        std::cout << "   脚本块&引用：优先选择id ({{#id}})\n";
        std::cout << "\n✨ 特殊说明:\n";
        std::cout << "   {{box}}不会自动添加，只有{{.box}}和{{#box}}能够触发自动化\n";
        std::cout << "   引用选择器&会根据上下文自动替换为合适的选择器\n";
        std::cout << "   系统已集成到CHTL编译器的Generator中\n";
        
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "测试失败: " << e.what() << std::endl;
        return 1;
    }
}